### 0028 Find the Index of the First Occurrence in a String: Python Solution

This solution checks every candidate substring of `haystack` that has the same length as `needle` using slicing and direct comparison.

Complexity
- Time: O(n * m) where `n = len(haystack)` and `m = len(needle)`.  
  The loop runs about `n - m + 1` times and each iteration creates a substring of length `m` and compares it to `needle`, giving O((n - m + 1) * m) → O(n * m). If `m` is Θ(n) this degenerates to O(n<sup>2</sup>).
- Space: O(m) auxiliary space per iteration because `substr = haystack[i:i+m]` creates a temporary string of length `m`. At any one time the extra space used is O(m).

Algorithm
1. Let `n = len(haystack)` and `m = len(needle)`.
2. Iterate `i` from `0` to `n - m` (inclusive):
   - Form `substr = haystack[i:i+m]`.
   - If `substr == needle`, return `i` (first occurrence found).
3. If no match is found, return `-1`.

Notes
- Edge case: if `needle` is empty (`m == 0`), the loop returns `0` (first valid position), matching common problem definitions.
- This implementation is clear and simple but can be inefficient on large inputs due to repeated substring allocations and comparisons.
- Optimizations:
  - Avoid allocating substrings by comparing characters in-place (check `haystack[i + j] == needle[j]` in a nested loop), which reduces temporary allocations but keeps worst-case time O(n * m).
  - Use a linear-time string-search algorithm such as KMP (Knuth–Morris–Pratt) for O(n + m) time and O(m) preprocessing space when needing better worst-case performance.

[Problem Link](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/?envType=study-plan-v2&envId=top-interview-150)