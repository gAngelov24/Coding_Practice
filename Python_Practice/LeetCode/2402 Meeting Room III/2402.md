### 2402 Meeting Rooms III: Python Solution

This solution schedules meetings greedily using two min-heaps: open_rooms for available room indices and busy_rooms for rooms currently occupied with their next free time. A bookings list (treated as a max-heap by storing negative counts) tracks how many times each room was assigned. The algorithm runs in O(m log n) time where m is number of meetings and n is number of rooms, and uses O(n + m) extra space for the heaps.

Algorithm:
1. Sort `meetings` by start time.
2. Initialize:
    - `open_rooms` (min-heap) with all room indices `0..n-1`.
    - `busy_rooms` (min-heap) empty; entries are `[free_time, room]`.
    - `bookings` list of length `n` with `[0, room]` for each room; counts are stored negative so that smaller values represent more bookings for heap usage.
3. For each meeting `m` with `start = m[0]`, `end = m[1]`, `dur = end - start`:
    - Pop from `busy_rooms` while the earliest `free_time <= start`, pushing freed room indices back into `open_rooms`.
    - If `open_rooms` is non-empty:
        - Pop the smallest available room.
        - Push `[start + dur, room]` into `busy_rooms` (room is now busy until that time).
        - Decrement `bookings[room][0]` to record one more booking (using negative counts).
    - Else (no room free at start):
        - Pop the earliest-finishing room `next_avail` from `busy_rooms`.
        - Extend its `free_time` by `dur` (it starts this meeting when it becomes free).
        - Push it back into `busy_rooms`.
        - Decrement `[bookings[next_avail[1]][0]]` to record the booking.
4. After processing all meetings, convert `bookings` into a heap (`heapq.heapify(bookings)`) so the room with the most bookings (most negative count) is at index 0; return its room index `bookings[0][1]`.


[Problem Link](https://leetcode.com/problems/meeting-rooms-iii/description/?envType=daily-question&envId=2025-12-27)