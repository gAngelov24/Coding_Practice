### LeetCode Question 0088: Merge Sorted Array Solution

Solution:
My initial solution I used makes use of the fact that we are given the size of both sorted arrays. It has a runtime of O(m + n), where n represents the size of `nums1` and m represents the size of `nums2`. Since my solution allocates a new `merged` vector it takes up an addition O(m + n) space which while not ideal, it did work. I will come back later to try and optimize its space usage

1. We start by checking if either of our arrays are empty, this is an edge case we must account for. 
2. If neither input is empty, we create an output array (`merged`) which we will copy into nums1 at the end. We also initialize the size of our final array (`size = n + m`) and index trackers to keep track of where we are in each array (`idx1` and `idx2`).
3. We iterate through the total size of `merged` which should be `n + m` elements. 
4. Each iteration we set a local variable `nums1` (the reason I don't set nums2 is because I was running into out of bounds errors) which stores the current value at `nums1[idx1]`
5. We check if `idx2 == n` which asks, "Have we reached the end of `nums2`?". If we have, we have no business looking at `nums2` again and we should push the rest of `nums1` into `merged`.
6. We then check if `num1 <= nums2[idx2]` which assures we push integers in non-decreasing order and account for when `nums1[idx1] == nums2[idx2]`.
7. Then one final check is to make sure we have not reached then end of nums1 (`idx1 != m`). This asks, "Have we reached the end of `nums1`?" If we have, we should not push any elements from `nums1` into `merged`
8. If we have not reached the end of `nums2` and `num1 > nums2[idx2]` then we can push `nums2[idx2]` to the back `merged` and increment `idx2`.
9. Use the helper function I made to copy `merged` into `nums1`.

[Problem Link](https://leetcode.com/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)
